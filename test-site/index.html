<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>FRW · Free Resilient Web · Field Notes</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');

    :root {
      --bg: #040d21;
      --bg-alt: #0a0f25;
      --accent: #75ffdf;
      --accent-strong: #32d3b1;
      --muted: #9aa4c6;
      --card: rgba(255, 255, 255, 0.04);
      --border: rgba(255, 255, 255, 0.08);
      --mono: 'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      --sans: 'Space Grotesk', 'Soehne', 'Favorit', 'Neue Montreal', 'Space Grotesk', system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--sans);
      background: radial-gradient(110% 120% at 10% 10%, #1c1f37, var(--bg) 55%);
      color: #f5f7ff;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'%3E%3Cg fill='%23ffffff' fill-opacity='0.02'%3E%3Crect x='0' y='0' width='1' height='1'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 0;
    }

    main {
      width: min(1200px, calc(100% - 3rem));
      margin: 0 auto;
      padding: 3.5rem 0 5rem;
      position: relative;
      z-index: 1;
    }

    header.hero {
      display: grid;
      gap: 1rem;
      margin-bottom: 3rem;
    }

    .eyebrow {
      font-size: 0.9rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
    }

    h1 {
      margin: 0;
      font-size: clamp(2.5rem, 5vw, 3.8rem);
      line-height: 1.1;
    }

    .lead {
      max-width: 60ch;
      color: #d7dbf5;
      font-size: 1.1rem;
      line-height: 1.5;
    }

    .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      margin-top: 1.5rem;
    }

    .primary {
      background: var(--accent);
      color: #042626;
      border: none;
      border-radius: 999px;
      padding: 0.8rem 1.8rem;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: transform 200ms ease, box-shadow 200ms ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 30px rgba(117, 255, 223, 0.3);
    }

    .secondary-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    section {
      margin-top: 3.5rem;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 1.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-height: 200px;
      position: relative;
    }

    .card h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .card p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .pill {
      align-self: flex-start;
      padding: 0.25rem 0.85rem;
      font-size: 0.75rem;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .pill.online {
      border-color: rgba(117, 255, 223, 0.4);
      color: var(--accent);
    }

    .network-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .summary-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 1.3rem 1.4rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }

    .summary-card span {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .summary-card strong {
      font-size: 1.8rem;
      font-family: var(--mono);
      color: var(--accent);
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
    }

    .status-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1rem 1.2rem;
      cursor: pointer;
      transition: border-color 200ms ease, transform 200ms ease;
    }

    .status-card:hover {
      border-color: rgba(117, 255, 223, 0.5);
      transform: translateY(-1px);
    }

    .status-card h4 {
      margin: 0;
      font-size: 0.95rem;
      color: #f8f9ff;
    }

    .status-card header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.6rem;
    }

    .status-card h4 {
      margin: 0;
      font-size: 1rem;
    }

    .status-card span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-family: var(--mono);
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status-card[data-state="online"] span {
      color: var(--accent);
    }

    .status-card.offline {
      border-color: rgba(255, 87, 87, 0.4);
    }

    .status-card dl {
      margin: 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.4rem 0.8rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status-card dt {
      font-weight: 600;
      color: #f0f3ff;
    }

    .sparkline-wrapper {
      margin-top: 0.75rem;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 0.4rem;
    }

    .sparkline-wrapper svg {
      width: 100%;
      height: 42px;
    }

    .sparkline-label {
      font-family: var(--mono);
      font-size: 0.75rem;
      color: var(--muted);
    }

    .sparkline-empty {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .node-detail {
      margin-top: 2rem;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(117, 255, 223, 0.15);
      border-radius: 20px;
      padding: 1.6rem;
      display: grid;
      gap: 1rem;
    }

    .detail-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .detail-header h3 {
      margin: 0;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      border-radius: 999px;
      padding: 0.2rem 0.9rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .chip.success {
      color: var(--accent);
      border-color: rgba(117, 255, 223, 0.5);
    }

    .chip.error {
      color: #ff8f9f;
      border-color: rgba(255, 143, 159, 0.5);
    }

    .chip.muted {
      color: var(--muted);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
    }

    .detail-grid div {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.07);
      border-radius: 12px;
      padding: 1rem;
    }

    .detail-grid span {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .detail-grid strong {
      display: block;
      margin-top: 0.5rem;
      font-family: var(--mono);
      font-size: 1rem;
      color: #fff;
      word-break: break-word;
    }

    .detail-meta {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .detail-meta code {
      background: rgba(255, 255, 255, 0.08);
      padding: 0.1rem 0.35rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .log-panel {
      margin-top: 2rem;
      background: linear-gradient(120deg, rgba(10, 16, 35, 0.95), rgba(5, 9, 20, 0.95));
      border-radius: 24px;
      border: 1px solid rgba(117, 255, 223, 0.1);
      padding: 2rem;
      display: grid;
      gap: 1.5rem;
    }

    .log-output {
      background: rgba(0, 0, 0, 0.35);
      border-radius: 18px;
      padding: 1.5rem;
      font-family: var(--mono);
      font-size: 0.9rem;
      line-height: 1.6;
      max-height: 260px;
      overflow: hidden;
      position: relative;
    }

    .log-output::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px solid rgba(117, 255, 223, 0.15);
      pointer-events: none;
    }

    .log-output p {
      margin: 0;
      color: #d1fffb;
      white-space: pre-wrap;
    }

    .log-output p + p {
      margin-top: 0.6rem;
    }

    .log-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.85rem;
      color: var(--muted);
    }

    dl.timeline {
      border-left: 1px solid rgba(255, 255, 255, 0.12);
      margin: 2rem 0 0;
      padding-left: 1.5rem;
    }

    dl.timeline dt {
      font-weight: 600;
      margin-top: 1rem;
      color: var(--accent);
    }

    dl.timeline dd {
      margin: 0.4rem 0 1rem;
      color: var(--muted);
      line-height: 1.5;
    }

    footer {
      margin-top: 4rem;
      padding-top: 2rem;
      border-top: 1px solid rgba(255, 255, 255, 0.07);
      color: var(--muted);
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    @media (max-width: 720px) {
      main {
        padding-top: 2.5rem;
      }

      .card {
        min-height: unset;
      }

      .log-panel {
        padding: 1.2rem;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .primary,
      .status-card {
        transition: none;
      }
    }
  </style>
</head>
<body>
  <main>
    <header class="hero">
      <p class="eyebrow">Field-ready · V2 protocol · Global relays</p>
      <h1>FRW / Free Resilient Web</h1>
      <p class="lead">
        Independent publishing infrastructure designed for real use:
        quantum-resistant keys, Argon2id PoW, distributed registries, and
        zero patience for hype. Everything you see below runs locally—no screenshots,
        no smoke, just the stack as shipped.
      </p>
      <div class="cta-row">
        <a class="primary" href="https://github.com/frw-community/FRW-Free-Web" target="_blank" rel="noreferrer">
          Inspect the code
          <span aria-hidden="true">↗︎</span>
        </a>
        <a class="secondary-link" href="https://github.com/frw-community/FRW-Free-Web/issues" target="_blank" rel="noreferrer">
          Issue tracker
        </a>
      </div>
    </header>

    <section aria-label="Launch checklist">
      <div class="card-grid">
        <article class="card">
          <span class="pill online">Ready</span>
          <h3>Protocol V2</h3>
          <p>Dilithium3 + Ed25519 hybrids, Argon2id proof-of-work, and
            DNS verification baked into the CLI. Bootstrap nodes enforce strict
            timestamps to keep the graph honest.</p>
        </article>
        <article class="card">
          <span class="pill online">Live</span>
          <h3>Swiss Bootstrap Pair</h3>
          <p>Two production nodes already online (Linux + Windows). Community nodes
            join organically—no central choke points, no one footing the planet’s bill.</p>
        </article>
        <article class="card">
          <span class="pill">Docs</span>
          <h3>Deployment Playbooks</h3>
          <p>From one-command setup to community-first strategy notes. Everything documented,
            ASCII only. The boring ops bits are already handled.</p>
        </article>
      </div>
    </section>

    <section aria-label="Runtime status">
      <h2>Status monitor</h2>
      <div class="network-summary" id="network-summary">
        <!-- summary cards inserted here -->
      </div>
      <div class="status-grid" id="status-grid">
        <!-- cards injected by JS -->
      </div>
      <div class="log-panel">
        <div class="log-meta">
          <span>Session: <strong>local-dev</strong></span>
          <span>Bootstrap topic: <code>frw/names/updates/v2</code></span>
          <span>IPFS Gateway: <code>localhost:5001</code></span>
        </div>
        <div class="log-output" id="log-output" aria-live="polite">
          <!-- log lines injected -->
        </div>
      </div>
      <div class="node-detail" id="node-detail">
        <div class="detail-header">
          <h3>Node detail</h3>
          <span class="chip muted" id="detail-status">Select a node</span>
        </div>
        <p id="detail-body" class="detail-meta">
          Choose any of the nodes above to inspect uptime, PQ-secure counts, discovery peers, and live HTTP latency.
        </p>
      </div>
    </section>

    <section aria-label="Timeline">
      <h2>Why now?</h2>
      <dl class="timeline">
        <dt>Oct → Nov</dt>
        <dd>Wrote the distributed registry, bootstrap services, and Chrome extension to browse <code>frw://</code> URLs without plugins.</dd>
        <dt>Dec 5</dt>
        <dd>Finished V2-only rollout. CLI, browser, and nodes reject V1 traffic. Publishing now fan-outs to every bootstrap node.</dd>
        <dt>Dec 6</dt>
        <dd>DNS verification lands. Add <code>frw-key</code> TXT record, run <code>frw verify-dns</code>, ship verified badges with every page.</dd>
      </dl>
    </section>

    <footer>
      <span>Hand-built. Zero generated copy.</span>
      <span>Last verified: <time id="last-verified"></time></span>
    </footer>
  </main>

  <script>
    const statusGrid = document.getElementById('status-grid');
    const summaryGrid = document.getElementById('network-summary');
    const logOutput = document.getElementById('log-output');
    const lastVerified = document.getElementById('last-verified');
    const detailPanel = document.getElementById('node-detail');
    const detailStatus = document.getElementById('detail-status');
    const detailBody = document.getElementById('detail-body');

    const bootstrapNodes = [
      { id: 'ch-alpha', label: 'Swiss Node · Alpha', url: 'http://83.228.214.189:3100' },
      { id: 'ch-beta', label: 'Swiss Node · Beta', url: 'http://83.228.213.45:3100' },
      { id: 'ch-gamma', label: 'Swiss Node · Gamma', url: 'http://83.228.213.240:3100' },
      { id: 'ch-delta', label: 'Swiss Node · Delta', url: 'http://83.228.214.72:3100' },
      { id: 'ipv6-core', label: 'Swiss Node · IPv6 Core', url: 'http://[2001:1600:18:102::165]:3100' },
      { id: 'us-alpha', label: 'US Node · Alpha', url: 'http://155.117.46.244:3100' },
      { id: 'us-beta', label: 'US Node · Beta', url: 'http://165.73.244.107:3100' },
      { id: 'us-gamma', label: 'US Node · Gamma', url: 'http://165.73.244.74:3100' },
      { id: 'es-alpha', label: 'Iberia Node · Alpha', url: 'http://217.216.32.99:3100' },
      { id: 'local', label: 'Local Dev', url: 'http://localhost:3100' }
    ];

    const nodeHistory = new Map();
    let activeNodeId = null;

    function formatNumber(value) {
      return new Intl.NumberFormat('en-US', { notation: value > 9999 ? 'compact' : 'standard' }).format(value);
    }

    async function fetchJson(url, timeout = 6000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);
      try {
        const response = await fetch(url, { signal: controller.signal });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return await response.json();
      } finally {
        clearTimeout(timer);
      }
    }

    async function fetchNodeStats(node) {
      const started = performance.now();
      try {
        // Try direct fetch first (works locally)
        const response = await fetch(`${node.url}/health`, { 
          mode: 'cors',
          signal: AbortSignal.timeout(5000)
        });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const health = await response.json();
        
        // Try stats endpoint
        let stats = null;
        let peers = 0;
        try {
          stats = await fetch(`${node.url}/api/stats`, {
            mode: 'cors',
            signal: AbortSignal.timeout(3000)
          }).then(r => r.ok ? r.json() : null);
          
          // Try discovery endpoint for peers
          try {
            const discovery = await fetch(`${node.url}/api/nodes`, {
              mode: 'cors',
              signal: AbortSignal.timeout(3000)
            });
            if (discovery.ok) {
              const data = await discovery.json();
              peers = data?.nodes?.length ?? 0;
            }
          } catch (_) {}
        } catch (_) {}
        
        return {
          node,
          online: true,
          latency: performance.now() - started,
          health,
          stats: stats || { totalNames: health?.v2IndexSize || 0 },
          peers: peers,
          fetchedAt: new Date()
        };
      } catch (error) {
        // Fallback: Use FRW distributed registry to check node status
        try {
          const registryUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`${node.url}/health`)}`;
          const fallbackResponse = await fetch(registryUrl, { signal: AbortSignal.timeout(8000) });
          
          if (fallbackResponse.ok) {
            const health = await fallbackResponse.json();
            return {
              node,
              online: true,
              latency: performance.now() - started,
              health,
              stats: { totalNames: health?.v2IndexSize || 0 },
              peers: 0,
              fetchedAt: new Date(),
              viaFallback: true
            };
          }
        } catch (_) {}
        
        return {
          node,
          online: false,
          error: error instanceof Error ? error.message : String(error),
          fetchedAt: new Date()
        };
      }
    }

    function renderSummary(results) {
      const onlineNodes = results.filter(r => r.online);
      const offlineNodes = results.filter(r => !r.online);
      const totalNames = onlineNodes.reduce((acc, result) => acc + (result.stats?.totalNames ?? result.health?.v2IndexSize ?? 0), 0);
      const pqRecords = onlineNodes.reduce((acc, result) => acc + (result.health?.pqSecureRecords ?? 0), 0);
      const avgLatency = onlineNodes.length
        ? Math.round(onlineNodes.reduce((acc, r) => acc + r.latency, 0) / onlineNodes.length)
        : 0;

      summaryGrid.innerHTML = `
        <article class="summary-card">
          <span>Nodes online</span>
          <strong>${onlineNodes.length}/${bootstrapNodes.length}</strong>
          <small>${offlineNodes.length} offline (${offlineNodes.map(n => n.node.label).join(', ')})</small>
        </article>
        <article class="summary-card">
          <span>Records indexed</span>
          <strong>${formatNumber(totalNames)}</strong>
          <small>V2 + migrated V1</small>
        </article>
        <article class="summary-card">
          <span>Quantum-safe</span>
          <strong>${formatNumber(pqRecords)}</strong>
          <small>Dilithium3 + Argon2id</small>
        </article>
        <article class="summary-card">
          <span>Median latency</span>
          <strong>${avgLatency || '—'} ms</strong>
          <small>HTTP roundtrip</small>
        </article>
      `;
    }

    function updateHistory(result) {
      if (!result.online || !Number.isFinite(result.latency)) return;
      const history = nodeHistory.get(result.node.id) || [];
      history.push({ latency: result.latency, timestamp: Date.now() });
      if (history.length > 30) history.shift();
      nodeHistory.set(result.node.id, history);
    }

    function renderSparkline(nodeId) {
      const history = nodeHistory.get(nodeId) || [];
      if (history.length < 2) return '<div class="sparkline-empty">No telemetry yet</div>';

      const width = 140;
      const height = 38;
      const maxLatency = Math.max(...history.map(h => h.latency));
      const minLatency = Math.min(...history.map(h => h.latency));
      const spread = Math.max(maxLatency - minLatency, 1);

      const points = history.map((entry, index) => {
        const x = (index / (history.length - 1)) * width;
        const normalized = (entry.latency - minLatency) / spread;
        const y = height - normalized * height;
        return `${x.toFixed(1)},${y.toFixed(1)}`;
      }).join(' ');

      const latest = history[history.length - 1].latency.toFixed(0);

      return `
        <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
          <polyline
            fill="none"
            stroke="rgba(117, 255, 223, 0.8)"
            stroke-width="2"
            stroke-linecap="round"
            points="${points}"
          />
        </svg>
        <div class="sparkline-label">last: ${latest} ms</div>
      `;
    }

    function renderNodes(results) {
      statusGrid.innerHTML = '';

      results.forEach(result => {
        if (result.online) updateHistory(result);
        const card = document.createElement('article');
        card.className = `status-card ${result.online ? 'online' : 'offline'}`;
        card.dataset.state = result.online ? 'online' : 'offline';
        card.dataset.nodeId = result.node.id;

        if (result.online) {
          card.innerHTML = `
            <header>
              <h4>${result.node.label}</h4>
              <span>● online · ${result.latency.toFixed(0)}ms</span>
            </header>
            <dl>
              <dt>Names</dt>
              <dd>${formatNumber(result.stats?.totalNames ?? result.health?.v2IndexSize ?? 0)}</dd>
              <dt>PQ secure</dt>
              <dd>${formatNumber(result.health?.pqSecureRecords ?? 0)}</dd>
              <dt>Peers</dt>
              <dd>${result.peers}</dd>
              <dt>Uptime</dt>
              <dd>${formatUptime(result.health?.uptime)}</dd>
            </dl>
            <div class="sparkline-wrapper">
              ${renderSparkline(result.node.id)}
            </div>
          `;
        } else {
          card.innerHTML = `
            <header>
              <h4>${result.node.label}</h4>
              <span>○ offline</span>
            </header>
            <p style="color: var(--muted); font-size: 0.9rem;">
              ${result.error?.includes('fetch failed') 
                ? 'Network unreachable' 
                : result.error?.includes('timeout')
                ? 'Connection timeout'
                : result.error || 'No heartbeat'}
            </p>
          `;
        }

        card.addEventListener('click', () => showNodeDetail(result));
        statusGrid.appendChild(card);
      });
    }

    function renderLog(results) {
      logOutput.innerHTML = '';
      const now = new Date();
      const lines = results.map(result => {
        const timestamp = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        if (result.online) {
          return `[${timestamp}] ${result.node.label} → ${formatNumber(result.stats?.totalNames ?? 0)} names, ${result.latency.toFixed(0)}ms`;
        }
        return `[${timestamp}] ${result.node.label} → offline (${result.error || 'no response'})`;
      });

      lines.forEach(line => {
        const row = document.createElement('p');
        row.textContent = line;
        logOutput.appendChild(row);
      });
    }

    function formatUptime(seconds) {
      if (!Number.isFinite(seconds)) return '—';
      const hours = seconds / 3600;
      if (hours < 24) return `${hours.toFixed(1)} h`;
      return `${(hours / 24).toFixed(1)} d`;
    }

    function formatTimestamp(ts) {
      if (!ts) return '—';
      return new Date(ts).toLocaleString();
    }

    function showNodeDetail(result) {
      activeNodeId = result.node.id;
      if (!result.online) {
        detailStatus.className = 'chip error';
        detailStatus.textContent = 'offline';
        detailBody.innerHTML = `
          <p class="detail-meta">
            ${result.node.label} is currently offline. Last attempt: ${result.fetchedAt.toLocaleTimeString()}.
            ${result.error ? `Error: ${result.error}` : ''}
          </p>
        `;
        return;
      }

      detailStatus.className = 'chip success';
      detailStatus.textContent = `online · ${result.latency.toFixed(0)} ms`;

      detailBody.innerHTML = `
        <div class="detail-grid">
          <div>
            <span>Identity</span>
            <strong>${result.health?.nodeId || 'Unknown'}</strong>
          </div>
          <div>
            <span>Total names</span>
            <strong>${formatNumber(result.stats?.totalNames ?? result.health?.v2IndexSize ?? 0)}</strong>
          </div>
          <div>
            <span>PQ secure</span>
            <strong>${formatNumber(result.health?.pqSecureRecords ?? 0)}</strong>
          </div>
          <div>
            <span>Peers discovered</span>
            <strong>${result.peers}</strong>
          </div>
          <div>
            <span>HTTP endpoint</span>
            <strong>${result.node.url}</strong>
          </div>
          <div>
            <span>IPFS upstream</span>
            <strong>${result.stats?.ipfsUrl || result.health?.ipfsUrl || 'n/a'}</strong>
          </div>
        </div>
        <p class="detail-meta">
          Uptime: <code>${formatUptime(result.health?.uptime)}</code> · Last publish: <code>${formatTimestamp(result.health?.lastPublished || result.stats?.lastPublished)}</code> · Sample captured ${result.fetchedAt.toLocaleTimeString()}.
        </p>
      `;
    }

    async function refreshNetwork() {
      const results = await Promise.all(bootstrapNodes.map(fetchNodeStats));
      renderSummary(results);
      renderNodes(results);
      renderLog(results);

      lastVerified.textContent = new Date().toLocaleString(undefined, {
        dateStyle: 'medium',
        timeStyle: 'short'
      });

      const selected = results.find(r => r.node.id === activeNodeId);
      if (selected) {
        showNodeDetail(selected);
      } else {
        const fallback = results.find(r => r.online);
        if (!activeNodeId && fallback) {
          showNodeDetail(fallback);
        }
      }
    }

    refreshNetwork();
    setInterval(refreshNetwork, 20000);
  </script>
</body>
</html>
